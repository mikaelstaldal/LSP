/*
 * Copyright (c) 2003-2008, Mikael St√•ldal
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the author nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *
 * Note: This is known as "the modified BSD license". It's an approved
 * Open Source and Free Software license, see
 * http://www.opensource.org/licenses/
 * and
 * http://www.gnu.org/philosophy/license-list.html
 */

package nu.staldal.lsp.compiler;

import java.io.*;
import java.util.*;

import org.xml.sax.*;

import nu.staldal.util.Environment;
import nu.staldal.lsp.*;
import nu.staldal.lsp.expr.*;
import nu.staldal.lsp.compile.*;
import nu.staldal.lsp.compiledexpr.*;

import org.apache.bcel.Constants;
import org.apache.bcel.classfile.Field;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.classfile.Unknown;
import org.apache.bcel.generic.*;


/**
 * Compiles an LSP page into JVM bytecode.
 *<p>
 * An instance of this class may be reused, but is not thread safe.
 */
class LSPJVMCompiler implements Constants
{
	private static final String EXT_LIBS_URLS = "_extLibsURLs";
	private static final String EXT_LIBS_CLASS_NAMES = "_extLibsClassNames";
	private static final String COMPILE_DEPENDENT_FILES = "_compileDependentFiles"; 

	// private static final int PARAM_this = 0;
	private static final int PARAM_origSax = 1;
	private static final int PARAM_env = 2;
	private static final int PARAM_extLibs = 3;
	private static final int PARAM_sax = 4;
	private static final int PARAM_attrs = 5;
    
    private boolean acceptUnbound;
    
	private String className = null;
	private ClassGen classGen = null;
	private ConstantPoolGen constGen = null;
	private InstructionFactory instrFactory = null;
    private HashMap<String,Integer> sourceFiles = null;
    private int[] maxLineNumber = null;
	
	private int splitNumber;
    

    LSPJVMCompiler()
    {
        // default constructor
    }


    private String getFileName(String path)
    {
        int i = path.lastIndexOf('/');
        if (i == -1)
            return path;
        else
            return path.substring(i+1);
    }
    
	
	/**
	 * @param out  where to write the generated bytecode
	 */
    void compileToByteCode(String pageName, LSPNode theTree, 
		    HashMap<String,String> importedFiles, boolean compileDynamic,
            HashMap<String,String> extLibsInPage, Properties outputProperties, 
            OutputStream out, boolean acceptUnbound, boolean hasEnclose)
        throws IOException, SAXException
	{
        this.acceptUnbound = acceptUnbound;
        
		splitNumber = 0;
		
		className = "_LSP_"+pageName;		
		
		classGen = new ClassGen(className, 
			"nu.staldal.lsp.LSPPageBase",
			pageName+".lsp", 
			ACC_PUBLIC | ACC_FINAL | ACC_SUPER,
			new String[] {}); 
        
        classGen.setMajor(49);
        classGen.setMinor(0);

		constGen = classGen.getConstantPool();

		instrFactory = new InstructionFactory(classGen, constGen);
        
        sourceFiles = new HashMap<String,Integer>(importedFiles.size() + (hasEnclose ? 1 : 0));
        
        StringBuffer sourceMap = new StringBuffer();
        sourceMap.append("SMAP\n");
        sourceMap.append(pageName+".lsp" + '\n');               
        sourceMap.append("LSP\n");        
        sourceMap.append("*S LSP\n");        
        sourceMap.append("*F\n");        
        {
            int i = 1;
            sourceMap.append(i + " " + pageName+".lsp" + '\n');
            if (hasEnclose)
            {
                i++;
                sourceMap.append(i + " " + getFileName(theTree.getSystemId()) + '\n');
                sourceFiles.put(theTree.getSystemId(), Integer.valueOf(i));                
            }
            for (String key : importedFiles.keySet())
            {
                i++;
                sourceMap.append(i + " " + getFileName(key) + '\n');
                sourceFiles.put(importedFiles.get(key), Integer.valueOf(i));
            }
        }
        maxLineNumber = new int[sourceFiles.size()+2];
			
		classGen.addField(makeStringArrayField(EXT_LIBS_URLS, constGen));
		classGen.addField(makeStringArrayField(EXT_LIBS_CLASS_NAMES, constGen));
		classGen.addField(makeStringArrayField(COMPILE_DEPENDENT_FILES, constGen));
		
		InstructionList instrList = new InstructionList();
		MethodGen constr = new MethodGen(ACC_PUBLIC, Type.VOID, Type.NO_ARGS, 
			new String[] {}, "<init>", className, instrList, constGen);
		instrList.append(instrFactory.createLoad(Type.OBJECT, 0));
        instrList.append(InstructionConstants.DUP);
		instrList.append(instrFactory.createFieldAccess(className, EXT_LIBS_URLS, new ArrayType(Type.STRING, 1), GETSTATIC));
		instrList.append(instrFactory.createFieldAccess(className, EXT_LIBS_CLASS_NAMES, new ArrayType(Type.STRING, 1), GETSTATIC));
		instrList.append(instrFactory.createFieldAccess(className, COMPILE_DEPENDENT_FILES, new ArrayType(Type.STRING, 1), GETSTATIC));
		instrList.append(new PUSH(constGen, compileDynamic ? 1 : 0));
		instrList.append(new PUSH(constGen, System.currentTimeMillis()));
		instrList.append(new PUSH(constGen, pageName));
		instrList.append(new PUSH(constGen, LSPPage.LSP_VERSION_NAME));
		instrList.append(new PUSH(constGen, LSPPage.LSP_VERSION_NUM));
		instrList.append(instrFactory.createInvoke(LSPPageBase.class.getName(), 
			"<init>", Type.VOID, 
			new Type[] { new ArrayType(Type.STRING, 1), new ArrayType(Type.STRING, 1), 
                new ArrayType(Type.STRING, 1), Type.BOOLEAN, Type.LONG, Type.STRING, 
                Type.STRING, Type.INT }, 
			INVOKESPECIAL));
        for (Enumeration<?> e = outputProperties.propertyNames(); e.hasMoreElements(); )
        {
            String key = (String)e.nextElement();
            String value = outputProperties.getProperty(key);
            
            instrList.append(InstructionConstants.DUP);
            instrList.append(new PUSH(constGen, key));
            instrList.append(new PUSH(constGen, value));
            instrList.append(instrFactory.createInvoke(LSPPageBase.class.getName(), 
                "setOutputProperty", Type.VOID, 
                new Type[] { Type.STRING, Type.STRING }, 
                INVOKEVIRTUAL));
        }
        instrList.append(InstructionConstants.POP);
		instrList.append(instrFactory.createReturn(Type.VOID));
		constr.setMaxStack();
		constr.setMaxLocals();
		classGen.addMethod(constr.getMethod());
		instrList.dispose();
		constr = null;

		ArrayList<String> extLibsURLs = new ArrayList<String>(extLibsInPage.size());
		ArrayList<String> extLibsClassNames = new ArrayList<String>(extLibsInPage.size());
		for (Map.Entry<String,String> ent : extLibsInPage.entrySet())
		{
			extLibsURLs.add(ent.getKey());
			extLibsClassNames.add(ent.getValue());
		}
		
		instrList = new InstructionList();
		MethodGen staticInit = new MethodGen(ACC_STATIC, Type.VOID, Type.NO_ARGS, 
			new String[] {}, "<clinit>", className, instrList, constGen);

		instrList.append(new PUSH(constGen, extLibsURLs.size()));
		instrList.append(instrFactory.createNewArray(Type.STRING, (short)1));
		for (int i = 0; i<extLibsURLs.size(); i++)
		{
			instrList.append(InstructionConstants.DUP);
			instrList.append(new PUSH(constGen, i));
			instrList.append(new PUSH(constGen, extLibsURLs.get(i)));
			instrList.append(InstructionConstants.AASTORE);
		}		
		instrList.append(instrFactory.createFieldAccess(className, EXT_LIBS_URLS, new ArrayType(Type.STRING, 1), PUTSTATIC));
		
		instrList.append(new PUSH(constGen, extLibsClassNames.size()));
		instrList.append(instrFactory.createNewArray(Type.STRING, (short)1));
		for (int i = 0; i<extLibsClassNames.size(); i++)
		{
			instrList.append(InstructionConstants.DUP);
			instrList.append(new PUSH(constGen, i));
			instrList.append(new PUSH(constGen, extLibsClassNames.get(i)));
			instrList.append(InstructionConstants.AASTORE);
		}		
		instrList.append(instrFactory.createFieldAccess(className, EXT_LIBS_CLASS_NAMES, new ArrayType(Type.STRING, 1), PUTSTATIC));
		
		instrList.append(new PUSH(constGen, importedFiles.size()));
		instrList.append(instrFactory.createNewArray(Type.STRING, (short)1));
		{ int i = 0;
		for (Iterator<String> iter = importedFiles.keySet().iterator(); 
			 iter.hasNext(); i++)
		{
			instrList.append(InstructionConstants.DUP);
			instrList.append(new PUSH(constGen, i));
			instrList.append(new PUSH(constGen, iter.next()));
			instrList.append(InstructionConstants.AASTORE);
		} }		
		instrList.append(instrFactory.createFieldAccess(className, COMPILE_DEPENDENT_FILES, new ArrayType(Type.STRING, 1), PUTSTATIC));
		
		instrList.append(instrFactory.createReturn(Type.VOID));
		staticInit.setMaxStack();
		staticInit.setMaxLocals();
		classGen.addMethod(staticInit.getMethod());
		instrList.dispose();
		staticInit = null;
				
		Method theMethod;
		int methodLength;

		try {
            theMethod = createExecuteMethod("_execute", theTree, 0);
			methodLength = theMethod.getCode().getCode().length;
		}
		catch (ClassGenException e)
		{
			theMethod = null;
			methodLength = Integer.MAX_VALUE;
		}

		if (methodLength > 65535)
		{
			theMethod = createExecuteMethod("_execute", theTree, 1);
			methodLength = theMethod.getCode().getCode().length;
			if (methodLength > 65535)
				throw new LSPException("Generated method too large: " + methodLength);
		}
		
		classGen.addMethod(theMethod);
        
        sourceMap.append("*L\n");

        for (int i = 1; i<maxLineNumber.length; i++)
        {
            int fakeLineNumber = (i==1) ? 1 : 10000+1000*i+1;
            sourceMap.append("1#"+i+","+maxLineNumber[i]+":"+fakeLineNumber+",1\n");                    
        }
        sourceMap.append("*V\n");
        sourceMap.append("nu.staldal.lsp\n");
        sourceMap.append("*E\n");
        byte[] smap = sourceMap.toString().getBytes("UTF-8");
        sourceMap = null;
        classGen.addAttribute(new Unknown(constGen.addUtf8("SourceDebugExtension"),
            smap.length, smap, 
            constGen.getConstantPool()));
        smap = null;
			
		JavaClass generatedClass = classGen.getJavaClass();
		generatedClass.dump(out);
		
		instrFactory = null;
		constGen = null;
		classGen = null;
		className = null;
    }

		
	private Field makeStringArrayField(String fieldName, 
		ConstantPoolGen constGen)
	{
		FieldGen fieldGen = new FieldGen(
			ACC_PRIVATE | ACC_STATIC | ACC_FINAL,
			new ArrayType(Type.STRING,1),
			fieldName,
			constGen);
		
		return fieldGen.getField();
	}
	
		
	private Method createExecuteMethod(String methodName, LSPNode theTree, int split)
        throws SAXException, ClassGenException
	{
		InstructionList instrList = new InstructionList();
		
		MethodGen methodGen = new MethodGen(ACC_PROTECTED|ACC_FINAL,
								  Type.VOID,		// return types	
								  new Type[] { Type.getType(ContentHandler.class),
											   Type.getType(Environment.class),
											   Type.getType(Map.class),     
											   Type.getType(ContentHandler.class),     
											   Type.getType(org.xml.sax.helpers.AttributesImpl.class) },     
								  new String[] { "sax", "env", 
								  				 "extLibs", "_sax", "_attrs" }, // arg names
								  methodName,		// method name 
								  className,     	// class name
								  instrList, constGen);
	
		compileNode(theTree, methodGen, instrList,  split);		
		
		// code at end
		instrList.append(instrFactory.createReturn(Type.VOID));

		methodGen.addException(SAXException.class.getName());
		methodGen.addException(IllegalArgumentException.class.getName());

		methodGen.removeNOPs();		
	
		methodGen.setMaxStack();
		methodGen.setMaxLocals();
		
		Method m = methodGen.getMethod();
		
		instrList.dispose();
		
		return m;		
	}


	private Method createSplitMethod(LSPNode theNode)
		throws SAXException	
	{
		String methodName = "_executeSplit" + (splitNumber++);
		
		Method theMethod;
		int methodLength;

		try {
			theMethod = createExecuteMethod(methodName, theNode, 0);
			methodLength = theMethod.getCode().getCode().length;
		}
		catch (ClassGenException e)
		{
			theMethod = null;
			methodLength = Integer.MAX_VALUE;
		}

		if (methodLength > 65535)
		{
            try {
                theMethod = createExecuteMethod(methodName, theNode, 1);
                methodLength = theMethod.getCode().getCode().length;
            }
            catch (ClassGenException e)
            {
				throw new LSPException("Generated split method too large: " + e.getMessage());
            }
			if (methodLength > 65535)
				throw new LSPException("Generated split method too large: " + methodLength);
		}
		
        return theMethod;
   	}
	

	private void compileNode(LSPNode node, 
			MethodGen methodGen, InstructionList instrList, 
			int split)
        throws SAXException
    {
        if (node instanceof LSPSimpleContainer)
        {
            compileChildren((LSPSimpleContainer)node, methodGen, instrList, split);
        }
        else
        {
            Integer _fileId = sourceFiles.get(node.getSystemId());
            
            if (_fileId != null)
            {
                int fakeLineNumber = 
                    10000+1000*_fileId.intValue()+node.getLineNumber(); 
                
                methodGen.addLineNumber(instrList.append(InstructionConstants.NOP),
                    fakeLineNumber);
                    
                maxLineNumber[_fileId.intValue()] = node.getLineNumber();
            }
            else
            {
                methodGen.addLineNumber(instrList.append(InstructionConstants.NOP),
                    node.getLineNumber());
                    
                maxLineNumber[1] = node.getLineNumber();
            }            
            
            if (node instanceof LSPExtElement)
                compileNode((LSPExtElement)node, methodGen, instrList, split);
            else if (node instanceof LSPElement)
                compileNode((LSPElement)node, methodGen, instrList, split);
            else if (node instanceof LSPText)
                compileNode((LSPText)node, methodGen, instrList, split);
            else if (node instanceof LSPIf)
                compileNode((LSPIf)node, methodGen, instrList, split);
            else if (node instanceof LSPChoose)
                compileNode((LSPChoose)node, methodGen, instrList, split);
            else if (node instanceof LSPForEach)
                compileNode((LSPForEach)node, methodGen, instrList, split);
            else if (node instanceof LSPLet)
                compileNode((LSPLet)node, methodGen, instrList, split);
            else if (node instanceof LSPTemplate)
                compileNode((LSPTemplate)node, methodGen, instrList, split);
            else if (node instanceof LSPProcessingInstruction)
                compileNode((LSPProcessingInstruction)node, methodGen, instrList, split);
            else
                throw new SAXParseException("Unrecognized LSPNode: "
                    + node.getClass().getName(), node);
        }
    }

	
	private void compileChildren(LSPContainer el,
			MethodGen methodGen, InstructionList instrList, 
			int split)
		throws SAXException
	{
		for (int i = 0; i < el.numberOfChildren(); i++)
		{
			LSPNode child = el.getChild(i);
			if (split > 0)
			{
				Method splitMethod = createSplitMethod(child);
                
                if (splitMethod.getCode().getCode().length > 20)
                {                
                    classGen.addMethod(splitMethod);
    
                    instrList.append(instrFactory.createThis());
                    instrList.append(instrFactory.createLoad(
                        Type.getType(org.xml.sax.ContentHandler.class),
                        PARAM_origSax));
                    instrList.append(instrFactory.createLoad(
                        Type.getType(Environment.class),
                        PARAM_env));
                    instrList.append(instrFactory.createLoad(
                        Type.getType(Map.class),
                        PARAM_extLibs));
                    instrList.append(instrFactory.createLoad(
                        Type.getType(org.xml.sax.ContentHandler.class),
                        PARAM_sax));
                    instrList.append(instrFactory.createLoad(
                        Type.getType(org.xml.sax.helpers.AttributesImpl.class),
                        PARAM_attrs));
                        
                    instrList.append(instrFactory.createInvoke(
                        className,
                        splitMethod.getName(), Type.VOID, 
                        new Type[] { Type.getType(ContentHandler.class),
                                     Type.getType(Environment.class),
                                     Type.getType(Map.class),     
                                     Type.getType(ContentHandler.class),     
                                     Type.getType(org.xml.sax.helpers.AttributesImpl.class) },     
                        INVOKEVIRTUAL));
                }
                else
                {
                    compileNode(child, methodGen, instrList, 0);
                }
			}				
			else
			{
				compileNode(child, methodGen, instrList, split);
			}
		}
	}

	
	private void compileNode(LSPElement el,
			MethodGen methodGen, InstructionList instrList, 
			int split)
        throws SAXException
    {
		for (int i = 0; i < el.numberOfNamespaceMappings(); i++)
		{
			instrList.append(instrFactory.createLoad(
				Type.getType(org.xml.sax.ContentHandler.class),
				PARAM_sax));

			String[] m = el.getNamespaceMapping(i);

			// sax.startPrefixMapping(m[0], m[1]);			
			instrList.append(new PUSH(constGen, m[0]));
			instrList.append(new PUSH(constGen, m[1]));
			instrList.append(instrFactory.createInvoke(
				ContentHandler.class.getName(),
				"startPrefixMapping",
				Type.VOID,
				new Type[] { Type.STRING, Type.STRING },
				INVOKEINTERFACE));
		}
		
		instrList.append(instrFactory.createLoad(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));

		instrList.append(instrFactory.createLoad(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_attrs));
		instrList.append(InstructionConstants.DUP);
		instrList.append(instrFactory.createInvoke(
			org.xml.sax.helpers.AttributesImpl.class.getName(),
			"clear", Type.VOID, Type.NO_ARGS, 
			INVOKEVIRTUAL));
		
		for (int i = 0; i < el.numberOfAttributes(); i++)
		{
			LSPExpr localExpr = el.getAttributeLocalName(i);
			
			if ((localExpr instanceof StringLiteral)
					&& ((StringLiteral)localExpr).getValue().length() == 0)
				continue;
			
			instrList.append(InstructionConstants.DUP); // DUP _saxAtts

			// String URL = evalExprAsString(el.getAttributeNamespaceURI(i));
			compileExprAsString(el.getAttributeNamespaceURI(i), methodGen, instrList);
						
			if ((localExpr instanceof StringLiteral)
					&& 	((StringLiteral)localExpr).getValue().indexOf(':') > -1)
				throw new SAXParseException("<lsp:attribute> may not use QName", el);

			if ((localExpr instanceof StringLiteral)
					&& 	((StringLiteral)localExpr).getValue().equals("xmlns"))
				throw new SAXParseException("<lsp:attribute> may not add xmlns", el);
				
			// String local = evalExprAsString(el.getAttributeLocalName(i));
			compileExprAsString(localExpr, methodGen, instrList);
			
			BranchInstruction longBranch = null; 

			if ((localExpr instanceof StringLiteral)
					&& ((StringLiteral)localExpr).getValue().length() > 0)
            {
				
            }
			else
			{
				// if (local.length() == 0) continue; // ignore attributes with empty name
				instrList.append(InstructionConstants.DUP);
				instrList.append(instrFactory.createInvoke(
					String.class.getName(), "length", 
					Type.INT, Type.NO_ARGS, INVOKEVIRTUAL));
				BranchInstruction shortBranch = instrFactory.createBranchInstruction(
					IFNE, null);
				instrList.append(shortBranch);
				instrList.append(InstructionConstants.POP2);
				instrList.append(InstructionConstants.POP);
				longBranch = instrFactory.createBranchInstruction(GOTO, null);
				instrList.append(longBranch);
				shortBranch.setTarget(instrList.append(InstructionConstants.NOP));
			}				
			
			// String qName = "";
			instrList.append(new PUSH(constGen, ""));
			
			// String type = el.getAttributeType(i);
			instrList.append(new PUSH(constGen, el.getAttributeType(i)));

			// String value = evalExprAsString(el.getAttributeValue(i));
            Class<?> valueType = compileExpr(
                el.getAttributeValue(i), methodGen, instrList);
            if (valueType == Boolean.class)
            {
                try {
                    instrList.delete(instrList.getEnd());
                }
                catch (TargetLostException e)
                {
                    throw new LSPException("Internal error in LSP compiler: " + e.getMessage());	
                }
                
				BranchInstruction shortBranch = instrFactory.createBranchInstruction(
					IFNE, null);
				instrList.append(shortBranch);
				instrList.append(InstructionConstants.POP2);
				instrList.append(InstructionConstants.POP2);
				instrList.append(InstructionConstants.POP);
				longBranch = instrFactory.createBranchInstruction(GOTO, null);
				instrList.append(longBranch);
				shortBranch.setTarget(instrList.append(InstructionConstants.NOP));
                compileExprAsString(localExpr, methodGen, instrList);
            }            
            else if (valueType == String.class)
            {
                
            }
            else
            {
                instrList.append(instrFactory.createInvoke(
                    LSPPageBase.class.getName(),
                    "convertToString",
                    Type.STRING,
                    new Type[] { Type.OBJECT },
                    INVOKESTATIC));
            }

			// saxAtts.addAttribute(URI, local, qName, type, value);
			instrList.append(instrFactory.createInvoke(
				org.xml.sax.helpers.AttributesImpl.class.getName(), 
				"addAttribute", 
				Type.VOID, 
				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING }, 
				INVOKEVIRTUAL));			
			
			if (longBranch != null)
				longBranch.setTarget(instrList.append(InstructionConstants.NOP));			
		}

		LocalVariableGen _nsURI = methodGen.addLocalVariable("nsURI",
        	Type.STRING, null, null);			
		LocalVariableGen _localName = methodGen.addLocalVariable("localName",
        	Type.STRING, null, null);			
		
		if (el.getLocalName() == null)
		{
			// (el.getNamespaceURIExpr() != null) 
			//	? evalExprAsString(el.getNamespaceURIExpr())
			//	: "";
			if (el.getNamespaceURIExpr() != null)
				compileExprAsString(el.getNamespaceURIExpr(), methodGen, instrList);
			else
				instrList.append(new PUSH(constGen, ""));

			// String nsURI = evalExprAsString(el.getNamespaceURIExpr());
			instrList.append(InstructionConstants.DUP); 			
			_nsURI.setStart(instrList.append(new ASTORE(_nsURI.getIndex())));		  					
			
			instrList.append(InstructionConstants.SWAP); // swap _saxAttr									
			
			LSPExpr localNameExpr = el.getLocalNameExpr(); 
			
			if ((localNameExpr instanceof StringLiteral)
					&& 	((StringLiteral)localNameExpr).getValue().indexOf(':') > -1)
				throw new SAXParseException("<lsp:element> may not use QName", el);

			// String localName = evalExprAsString(el.getLocalNameExpr());
			compileExprAsString(localNameExpr, methodGen, instrList);
			instrList.append(InstructionConstants.DUP); 			
			_localName.setStart(instrList.append(new ASTORE(_localName.getIndex())));		  		

			instrList.append(InstructionConstants.SWAP); // swap _saxAttr			
		}
		else
		{
			// String nsURI = el.getNamespaceURI();
			instrList.append(new PUSH(constGen, el.getNamespaceURI()));
			instrList.append(InstructionConstants.DUP); 			
			_nsURI.setStart(instrList.append(new ASTORE(_nsURI.getIndex())));		  					

			instrList.append(InstructionConstants.SWAP); // swap _saxAttr			
					
			// String localName = el.getLocalName();
			instrList.append(new PUSH(constGen, el.getLocalName()));
			instrList.append(InstructionConstants.DUP); 			
			_localName.setStart(instrList.append(new ASTORE(_localName.getIndex())));		  		

			instrList.append(InstructionConstants.SWAP); // swap _saxAttr			
		}
		
		// String qName = "";
		instrList.append(new PUSH(constGen, ""));

		instrList.append(InstructionConstants.SWAP); // swap _saxAttr
		
		// sax.startElement(nsURI, localName, qName, saxAtts);
		instrList.append(instrFactory.createInvoke(
			ContentHandler.class.getName(),
			"startElement",
			Type.VOID,
			new Type[] { Type.STRING, Type.STRING, Type.STRING, 
				Type.getType(org.xml.sax.Attributes.class) },
			INVOKEINTERFACE));
		
		compileChildren(el, methodGen, instrList, split);

		instrList.append(instrFactory.createLoad(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));
			
		instrList.append(new ALOAD(_nsURI.getIndex()));		  		
		instrList.append(new ALOAD(_localName.getIndex()));		  		
		
		// String qName = "";
		InstructionHandle endOfVars = instrList.append(new PUSH(constGen, ""));
		_nsURI.setEnd(endOfVars);
		_localName.setEnd(endOfVars);

		// sax.endElement(nsURI, localName, qName);
		instrList.append(instrFactory.createInvoke(
			ContentHandler.class.getName(),
			"endElement",
			Type.VOID,
			new Type[] { Type.STRING, Type.STRING, Type.STRING },
			INVOKEINTERFACE));
				
		for (int i = 0; i < el.numberOfNamespaceMappings(); i++)
		{
			instrList.append(instrFactory.createLoad(
				Type.getType(org.xml.sax.ContentHandler.class),
				PARAM_sax));

			String[] m = el.getNamespaceMapping(i);
			
			// sax.endPrefixMapping(m[0]);
			instrList.append(new PUSH(constGen, m[0]));
			instrList.append(instrFactory.createInvoke(
				ContentHandler.class.getName(),
				"endPrefixMapping",
				Type.VOID,
				new Type[] { Type.STRING },
				INVOKEINTERFACE));
		}
    }

    
	private void compileNode(LSPExtElement el,
			MethodGen methodGen, InstructionList instrList, 
			int split)	
        throws SAXException
    {		
		// LSPExtLib extLib = (LSPExtLib)extLibs.get(el.getClassName());
		instrList.append(instrFactory.createLoad(
			Type.getType(Map.class), PARAM_extLibs));
		instrList.append(new PUSH(constGen, el.getClassName()));
		instrList.append(instrFactory.createInvoke(
			Map.class.getName(),
			"get",
			Type.OBJECT,
			new Type[] { Type.OBJECT },
			INVOKEINTERFACE));

		instrList.append(InstructionConstants.DUP); // DUP extLib		  		
			
		// ContentHandler in = extLib.beforeElement(sax);
		instrList.append(instrFactory.createLoad(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));
		instrList.append(instrFactory.createInvoke(
			LSPExtLib.class.getName(),
			"beforeElement",
			Type.getType(ContentHandler.class),
			new Type[] { Type.getType(ContentHandler.class) },
			INVOKEINTERFACE));

		instrList.append(instrFactory.createLoad(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));
		instrList.append(InstructionConstants.SWAP);		  		
		instrList.append(instrFactory.createStore(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));

		compileNode((LSPElement)el, methodGen, instrList, split);

		instrList.append(instrFactory.createStore(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));
		
		// String res = extLib.afterElement();
		instrList.append(instrFactory.createInvoke(
			LSPExtLib.class.getName(),
			"afterElement",
			Type.STRING,
			Type.NO_ARGS,
			INVOKEINTERFACE));
				
		// if (res != null) outputStringWithoutCR(sax, res, false);
		instrList.append(InstructionConstants.DUP);		  		
		BranchInstruction branch1 = instrFactory.createBranchInstruction(
			IFNULL, null);
		instrList.append(branch1);
		
		instrList.append(instrFactory.createLoad(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));
		
		instrList.append(InstructionConstants.SWAP);
        instrList.append(new PUSH(constGen, 0));
		instrList.append(instrFactory.createInvoke(
			LSPPageBase.class.getName(),
			"outputStringWithoutCR",
			Type.VOID,
			new Type[] { Type.getType(ContentHandler.class), Type.STRING, Type.BOOLEAN },
			INVOKESTATIC));
		BranchInstruction branch2 = instrFactory.createBranchInstruction(
			GOTO, null);
		instrList.append(branch2);
		branch1.setTarget(instrList.append(InstructionConstants.POP));
		branch2.setTarget(instrList.append(InstructionConstants.NOP));
	}
		
	
    private void compileNode(LSPText text,
			MethodGen methodGen, InstructionList instrList, 
			int split)	
    {
        String chars = text.getValue();
        
		instrList.append(instrFactory.createLoad(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));

		// sax.characters(chars, 0, chars.length);
		instrList.append(new PUSH(constGen, chars));
		instrList.append(instrFactory.createInvoke(
			String.class.getName(), "toCharArray", 
			new ArrayType(Type.CHAR, 1), Type.NO_ARGS, INVOKEVIRTUAL));
		instrList.append(new PUSH(constGen, 0));
		instrList.append(new PUSH(constGen, chars.length()));
		instrList.append(instrFactory.createInvoke(
			ContentHandler.class.getName(),
			"characters",
			Type.VOID,
			new Type[] { new ArrayType(Type.CHAR, 1), Type.INT, Type.INT },
			INVOKEINTERFACE));
    }


	private void compileNode(LSPProcessingInstruction el,
			MethodGen methodGen, InstructionList instrList, 
			int split)	
		throws SAXException
	{
        // StringHandler sh = new StringHandler();
		instrList.append(instrFactory.createNew(
			(ObjectType)Type.getType(StringHandler.class)));
		instrList.append(InstructionConstants.DUP);			
		instrList.append(instrFactory.createInvoke(
			StringHandler.class.getName(), "<init>", Type.VOID, Type.NO_ARGS, 
			INVOKESPECIAL));
		instrList.append(instrFactory.createStore(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));

		compileNode(el.getData(), methodGen, instrList, split);

		instrList.append(instrFactory.createLoad(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));

		instrList.append(instrFactory.createLoad(
			Type.getType(ContentHandler.class), PARAM_origSax));

		instrList.append(InstructionConstants.DUP);
		instrList.append(instrFactory.createStore(
			Type.getType(org.xml.sax.ContentHandler.class),
			PARAM_sax));

		instrList.append(InstructionConstants.SWAP);
		compileExprAsString(el.getName(), methodGen, instrList);
		instrList.append(InstructionConstants.SWAP);
		
		// _data = sh.getBuf().toString();
		instrList.append(instrFactory.createInvoke(
			StringHandler.class.getName(), "getBuf", 
			Type.STRINGBUFFER, Type.NO_ARGS, INVOKEVIRTUAL));
		instrList.append(instrFactory.createInvoke(
			StringBuffer.class.getName(), "toString", 
			Type.STRING, Type.NO_ARGS, INVOKEVIRTUAL));
		
		// sax.processingInstruction(
		// 	evalExprAsString(el.getName()),
		//	_data);
		instrList.append(instrFactory.createInvoke(
			ContentHandler.class.getName(),
			"processingInstruction",
			Type.VOID,
			new Type[] { Type.STRING, Type.STRING },
			INVOKEINTERFACE));
	}


	private void compileNode(LSPIf el,
			MethodGen methodGen, InstructionList instrList, 
			int split)	
		throws SAXException
	{
		LSPExpr expr = el.getTest();
		compileExprAsBooleanValue(expr, methodGen, instrList);

		// if (evalExprAsBoolean(expr))
		BranchInstruction theBranch = instrFactory.createBranchInstruction(
			IFEQ, null);
		instrList.append(theBranch);

		compileNode(el.getBody(), methodGen, instrList, split);
		
		theBranch.setTarget(instrList.append(InstructionConstants.NOP));
	}


	private void compileNode(LSPChoose el,
			MethodGen methodGen, InstructionList instrList, 
			int split)	
		throws SAXException
	{
		InstructionHandle[] testCase = new InstructionHandle[el.getNWhens()];
		BranchInstruction[] branch1 = new BranchInstruction[el.getNWhens()];
		BranchInstruction[] branch2 = new BranchInstruction[el.getNWhens()];
		
		for (int i = 0; i<el.getNWhens(); i++)
		{
			LSPExpr expr = el.getWhenTest(i);
			testCase[i] = instrList.append(InstructionConstants.NOP);
			compileExprAsBooleanValue(expr, methodGen, instrList);

			// if (evalExprAsBoolean(expr))
			branch1[i] = instrFactory.createBranchInstruction(
				IFEQ, null);
			instrList.append(branch1[i]);
			
			compileNode(el.getWhenBody(i), methodGen, instrList, split);
			
			branch2[i] = instrFactory.createBranchInstruction(GOTO, null);
			instrList.append(branch2[i]);
		}

		for (int i = 0; i<(branch1.length-1); i++)
		{
			branch1[i].setTarget(testCase[i+1]);	
		}		
		
		LSPNode otherwise = el.getOtherwise();
		if (otherwise != null)
		{
			branch1[branch1.length-1].setTarget(
				instrList.append(InstructionConstants.NOP));	
			compileNode(otherwise, methodGen, instrList, split);
		}

		InstructionHandle atEnd = instrList.append(InstructionConstants.NOP);

		for (int i = 0; i<branch2.length; i++)
		{
			branch2[i].setTarget(atEnd);	
		}		

		if (otherwise == null)
		{
			branch1[branch1.length-1].setTarget(atEnd);
		}
	}


	private void compileNode(LSPForEach el,
			MethodGen methodGen, InstructionList instrList, 
			int split)	
		throws SAXException
	{
		// final Collection theList = evalExprAsList(el.getList());
		compileExprAsList(el.getList(), methodGen, instrList);

		// Iterator theIter = theList.listIterator();
		instrList.append(instrFactory.createInvoke(
			Collection.class.getName(),
			"iterator",
			Type.getType(Iterator.class),
			Type.NO_ARGS,
			INVOKEINTERFACE));
            
		if (el.getStatusObject() != null)
		{
			instrList.append(InstructionConstants.DUP); // DUP theIter	

			// new LSPForEachStatus(theIter);
			instrList.append(instrFactory.createNew(
				(ObjectType)Type.getType(LSPForEachStatus.class)));
			instrList.append(InstructionConstants.DUP_X1);			
			instrList.append(InstructionConstants.SWAP);
			instrList.append(instrFactory.createInvoke(
				LSPForEachStatus.class.getName(),
				"<init>", Type.VOID, 
				new Type[] { Type.getType(Iterator.class) }, 
				INVOKESPECIAL));			

            instrList.append(InstructionConstants.SWAP);	
		}            
		
		// while (theIter.hasNext())
		BranchInstruction loopStart = 
			instrFactory.createBranchInstruction(GOTO, null); 		
		instrList.append(loopStart);		
		InstructionHandle atStartOfLoop = 
			instrList.append(InstructionConstants.NOP);

		if (el.getStatusObject() != null)
		{
            instrList.append(InstructionConstants.SWAP);
            
            // status.next();
            instrList.append(InstructionConstants.DUP); // DUP status
            instrList.append(instrFactory.createInvoke(
                LSPForEachStatus.class.getName(),
                "next",
                Type.VOID,
                Type.NO_ARGS,
                INVOKEVIRTUAL));            

			instrList.append(InstructionConstants.SWAP);
        }            
            
		// Object o = theIter.next();
		instrList.append(InstructionConstants.DUP); // DUP theIter
		instrList.append(instrFactory.createInvoke(
			Iterator.class.getName(),
			"next",
			Type.OBJECT,
			Type.NO_ARGS,
			INVOKEINTERFACE));
				
		// env.pushFrame();
		instrList.append(instrFactory.createLoad(
			Type.getType(Environment.class), PARAM_env));
			
		instrList.append(instrFactory.createInvoke(
			Environment.class.getName(),
			"pushFrame",
			Type.VOID,
			Type.NO_ARGS,
			INVOKEVIRTUAL));		
		
		String var = el.getVariable();
		
		// env.bind(var, o);
		instrList.append(instrFactory.createLoad(
			Type.getType(Environment.class), PARAM_env));
		instrList.append(InstructionConstants.SWAP);
		instrList.append(new PUSH(constGen, var));		
		instrList.append(InstructionConstants.SWAP);		
		instrList.append(instrFactory.createInvoke(
			Environment.class.getName(),
			"bind",
			Type.OBJECT,
			new Type[] { Type.OBJECT, Type.OBJECT },
			INVOKEVIRTUAL));
		instrList.append(InstructionConstants.POP); // discard return value
			
		if (el.getStatusObject() != null)
		{
            instrList.append(InstructionConstants.SWAP);
            instrList.append(InstructionConstants.DUP);

            instrList.append(instrFactory.createLoad(
                Type.getType(Environment.class), PARAM_env));

            instrList.append(InstructionConstants.SWAP);
            instrList.append(new PUSH(constGen, el.getStatusObject()));		
            instrList.append(InstructionConstants.SWAP);		
                
            instrList.append(instrFactory.createInvoke(
				Environment.class.getName(),
				"bind",
				Type.OBJECT,
				new Type[] { Type.OBJECT, Type.OBJECT },
				INVOKEVIRTUAL));
			instrList.append(InstructionConstants.POP); // discard return value
            instrList.append(InstructionConstants.SWAP);
		}
		
		compileNode(el.getBody(), methodGen, instrList, split);
		
		// env.popFrame();
		instrList.append(instrFactory.createLoad(
			Type.getType(Environment.class), PARAM_env));
		instrList.append(instrFactory.createInvoke(
			Environment.class.getName(),
			"popFrame",
			Type.VOID,
			Type.NO_ARGS,
			INVOKEVIRTUAL));				

		// end while				
		loopStart.setTarget(
			instrList.append(InstructionConstants.DUP)); // DUP theIter
		instrList.append(instrFactory.createInvoke(
			Iterator.class.getName(),
			"hasNext",
			Type.BOOLEAN,
			Type.NO_ARGS,
			INVOKEINTERFACE));
		instrList.append(instrFactory.createBranchInstruction(
				IFNE, atStartOfLoop));
		
		instrList.append(InstructionConstants.POP); // POP theIter
		if (el.getStatusObject() != null)
		{
            instrList.append(InstructionConstants.POP); // POP status
        }
	}
		

	private void compileNode(LSPLet el,
			MethodGen methodGen, InstructionList instrList, 
			int split)	
		throws SAXException
	{
        // env.pushFrame();
		instrList.append(instrFactory.createLoad(
			Type.getType(Environment.class), PARAM_env));
		instrList.append(instrFactory.createInvoke(
			Environment.class.getName(),
			"pushFrame",
			Type.VOID,
			Type.NO_ARGS,
			INVOKEVIRTUAL));		
		
		for (int i = 0; i<el.getVars().length; i++)
		{
			// env.bind(el.getVars()[i], evalExpr(el.getValues()[i]));
			instrList.append(instrFactory.createLoad(
				Type.getType(Environment.class), PARAM_env));
			instrList.append(new PUSH(constGen, el.getVars()[i])); 
			compileExpr(el.getValues()[i], methodGen, instrList);
			instrList.append(instrFactory.createInvoke(
				Environment.class.getName(),
				"bind",
				Type.OBJECT,
				new Type[] { Type.OBJECT, Type.OBJECT },
				INVOKEVIRTUAL));
			instrList.append(InstructionConstants.POP); // discard return value			
		}
		
		compileNode(el.getBody(), methodGen, instrList, split);
		
		// env.popFrame();
		instrList.append(instrFactory.createLoad(
			Type.getType(Environment.class), PARAM_env));
		instrList.append(instrFactory.createInvoke(
			Environment.class.getName(),
			"popFrame",
			Type.VOID,
			Type.NO_ARGS,
			INVOKEVIRTUAL));				
	}


	private void compileNode(LSPTemplate el,
			MethodGen methodGen, InstructionList instrList, 
			int split)	
		throws SAXException
	{
		LSPExpr expr = el.getExpr();

		// Object o = evalExpr(expr);
		Class<?> type = compileExpr(expr, methodGen, instrList);
		
		if (type == String.class)
		{
			// outputStringWithoutCR(sax, text, disableOutputEscaping);
			instrList.append(instrFactory.createLoad(
				Type.getType(org.xml.sax.ContentHandler.class),
				PARAM_sax));
			instrList.append(InstructionConstants.SWAP);
			instrList.append(new PUSH(constGen,
                el.isDisableOutputEscaping() ? 1 : 0));
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"outputStringWithoutCR",
				Type.VOID,
				new Type[] { Type.getType(ContentHandler.class), Type.STRING, Type.BOOLEAN },
				INVOKESTATIC));		
		}
		else
		{
			// String text = convertToString(o);		
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"convertToString",
				Type.STRING,
				new Type[] { Type.OBJECT },
				INVOKESTATIC));		
	
			// outputStringWithoutCR(sax, text, disableOutputEscaping);
			instrList.append(instrFactory.createLoad(
				Type.getType(org.xml.sax.ContentHandler.class),
				PARAM_sax));
			instrList.append(InstructionConstants.SWAP);		  		
			instrList.append(new PUSH(constGen, 
                el.isDisableOutputEscaping() ? 1 : 0));
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"outputStringWithoutCR",
				Type.VOID,
				new Type[] { Type.getType(ContentHandler.class), Type.STRING, Type.BOOLEAN },
				INVOKESTATIC));		
		}
	}

	
	private Class<?> compileExpr(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)
		throws SAXException
	{
		if (expr instanceof StringLiteral)
		{
			return compileSubExpr((StringLiteral)expr, methodGen, instrList);
		}
		else if (expr instanceof NumberLiteral)
		{
			return compileSubExpr((NumberLiteral)expr, methodGen, instrList);
		}
		else if (expr instanceof VariableReference)
		{
			return compileSubExpr((VariableReference)expr, methodGen, instrList);
		}
		else
		{
			return compileSubExpr(expr, methodGen, instrList);
		}
	}
	

	private void compileExprAsString(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)
		throws SAXException
	{
		Class<?> type = compileExpr(expr, methodGen, instrList);
		if (type != String.class)
		{
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"convertToString",
				Type.STRING,
				new Type[] { Type.OBJECT },
				INVOKESTATIC));
		}
	}


	// returns double value
	@SuppressWarnings("unused")
	private void compileExprAsNumberValue(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)
		throws SAXException
	{
		Class<?> type = compileExpr(expr, methodGen, instrList);
		if (type != Double.class)
		{
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"convertToNumber",
				Type.DOUBLE,
				new Type[] { Type.OBJECT },
				INVOKESTATIC));
		}
		else
		{
			try {
				instrList.delete(instrList.getEnd());
			}
			catch (TargetLostException e)
			{
				throw new LSPException("Internal error in LSP compiler: " + e.getMessage());	
			}
		}	
	}

	
	// returns boolean value
	private void compileExprAsBooleanValue(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)
		throws SAXException
	{
		Class<?> type = compileExpr(expr, methodGen, instrList);
		if (type != Boolean.class)
		{
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				acceptUnbound ? "convertToBooleanAcceptNull" : "convertToBoolean",
				Type.BOOLEAN,
				new Type[] { Type.OBJECT },
				INVOKESTATIC));
		}
		else
		{
			try {
				instrList.delete(instrList.getEnd());
			}
			catch (TargetLostException e)
			{
				throw new LSPException("Internal error in LSP compiler: " + e.getMessage());	
			}
		}
	}


	private void compileExprAsList(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)
		throws SAXException
	{
		Class<?> type = compileExpr(expr, methodGen, instrList);
		if (type != Collection.class)
		{
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"convertToList",
				Type.getType(Collection.class),
				new Type[] { Type.OBJECT },
				INVOKESTATIC));
		}
	}

	
	@SuppressWarnings("unused")
	private void compileExprAsTuple(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)
		throws SAXException
	{
		Class<?> type = compileExpr(expr, methodGen, instrList);
		if (type != Map.class)
		{
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"convertToTuple",
				Type.getType(Map.class),
				new Type[] { Type.OBJECT },
				INVOKESTATIC));
		}
	}
	
	
	private Class<?> compileSubExpr(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)
		throws SAXException
	{
		if (expr instanceof StringLiteral)
		{
			return compileSubExpr((StringLiteral)expr, methodGen, instrList);
		}
		else if (expr instanceof NumberLiteral)
		{
			return compileSubExpr((NumberLiteral)expr, methodGen, instrList);
		}
		else if (expr instanceof VariableReference)
		{
			return compileSubExpr((VariableReference)expr, methodGen, instrList);
		}
		else if (expr instanceof BinaryExpr)
		{
			return compileSubExpr((BinaryExpr)expr, methodGen, instrList);
		}
		else if (expr instanceof UnaryExpr)
		{
			return compileSubExpr((UnaryExpr)expr, methodGen, instrList);
		}
		else if (expr instanceof BuiltInFunctionCall)
		{
			return compileSubExpr((BuiltInFunctionCall)expr, methodGen, instrList);
		}
		else if (expr instanceof ExtensionFunctionCall)
		{
			return compileSubExpr((ExtensionFunctionCall)expr, methodGen, instrList);
		}
		else if (expr instanceof TupleExpr)
		{
			return compileSubExpr((TupleExpr)expr, methodGen, instrList);
		}
		else if (expr instanceof ConditionalExpr)
		{
			return compileSubExpr((ConditionalExpr)expr, methodGen, instrList);
		}
        else
        {
			throw new LSPException("Unrecognized LSPExpr: "
				+ expr.getClass().getName());
		}
	}

	
	private Class<?> compileSubExpr(StringLiteral expr,
			MethodGen methodGen, InstructionList instrList)
	{
		instrList.append(new PUSH(constGen, expr.getValue()));

		return String.class;
	}
	

	private Class<?> compileSubExpr(NumberLiteral expr,
			MethodGen methodGen, InstructionList instrList)	
	{
		instrList.append(new PUSH(constGen, expr.getValue()));
		
		instrList.append(instrFactory.createInvoke(
			LSPPageBase.class.getName(), "doubleValueOf",
			Type.getType(Double.class),
			new Type[] { Type.DOUBLE },
			INVOKESTATIC));											
		return Double.class;
	}


	private Class<?> compileSubExpr(VariableReference expr,
			MethodGen methodGen, InstructionList instrList)
	{
		instrList.append(instrFactory.createLoad(
			Type.getType(Environment.class), PARAM_env));
		// String varName = expr.getName();
		instrList.append(new PUSH(constGen, expr.getName()));
		// Object o = env.lookup(varName);
		instrList.append(instrFactory.createInvoke(
			LSPPageBase.class.getName(),
			acceptUnbound ? "getVariableValueAcceptNull" : "getVariableValue",
			Type.OBJECT,
			new Type[] { Type.getType(Environment.class), Type.STRING },
			INVOKESTATIC));				

		return Object.class;
	}


	private Class<?> compileSubExpr(BinaryExpr expr,
			MethodGen methodGen, InstructionList instrList)
		throws SAXException
	{
		switch (expr.getOp())
		{
		case BinaryExpr.OR: {
			// if (evalExprAsBoolean(expr.getLeft()))
			//	return Boolean.TRUE;
			// else
			//	return Boolean.valueOf(evalExprAsBoolean(expr.getRight()));
			compileSubExprAsBooleanValue(expr.getLeft(), methodGen, instrList);
			BranchInstruction branch1 = instrFactory.createBranchInstruction(
				IFEQ, null);
			instrList.append(branch1);
			instrList.append(new PUSH(constGen, 1));
			BranchInstruction branch2 = 
				instrFactory.createBranchInstruction(GOTO, null); 					
			instrList.append(branch2);
			branch1.setTarget(instrList.append(InstructionConstants.NOP));
			compileSubExprAsBooleanValue(expr.getRight(), methodGen, instrList);
			branch2.setTarget(instrList.append(InstructionConstants.NOP));

			instrList.append(instrFactory.createInvoke(
				Boolean.class.getName(), "valueOf",
				Type.getType(Boolean.class),
				new Type[] { Type.BOOLEAN },
				INVOKESTATIC));			
			return Boolean.class;
			} 

		case BinaryExpr.AND: {
			// if (!evalExprAsBoolean(expr.getLeft()))
			//	return Boolean.FALSE;
			// else
			// 	return Boolean.valueOf(evalExprAsBoolean(expr.getRight()));
			compileSubExprAsBooleanValue(expr.getLeft(), methodGen, instrList);
			BranchInstruction branch1 = instrFactory.createBranchInstruction(
				IFNE, null);
			instrList.append(branch1);
			instrList.append(new PUSH(constGen, 0));
			BranchInstruction branch2 = 
				instrFactory.createBranchInstruction(GOTO, null); 					
			instrList.append(branch2);
			branch1.setTarget(instrList.append(InstructionConstants.NOP));
			compileSubExprAsBooleanValue(expr.getRight(), methodGen, instrList);
			branch2.setTarget(instrList.append(InstructionConstants.NOP));

			instrList.append(instrFactory.createInvoke(
				Boolean.class.getName(), "valueOf",
				Type.getType(Boolean.class),
				new Type[] { Type.BOOLEAN },
				INVOKESTATIC));			
			return Boolean.class;
			} 

		case BinaryExpr.EQ:
		case BinaryExpr.NE:	{
			// Object left = evalExpr(expr.getLeft());
			Class<?> leftType = compileSubExpr(expr.getLeft(), methodGen, instrList);
			// Object right = evalExpr(expr.getRight());
			Class<?> rightType = compileSubExpr(expr.getRight(), methodGen, instrList);

			if (leftType == Boolean.class && rightType == Boolean.class)
			{
				instrList.append(instrFactory.createInvoke(
					Boolean.class.getName(), "equals",
					Type.BOOLEAN,
					new Type[] { Type.OBJECT },
					INVOKEVIRTUAL));
			}
			else if (leftType == Double.class && rightType == Double.class)
			{
				instrList.append(instrFactory.createInvoke(
					Double.class.getName(), "equals",
					Type.BOOLEAN,
					new Type[] { Type.OBJECT },
					INVOKEVIRTUAL));								
			}
			else if (leftType == String.class && rightType == String.class)
			{
				instrList.append(instrFactory.createInvoke(
					String.class.getName(), "equals",
					Type.BOOLEAN,
					new Type[] { Type.OBJECT },
					INVOKEVIRTUAL));								
			}
			else
			{
				instrList.append(instrFactory.createInvoke(
					LSPPageBase.class.getName(),
					"compareEqual",
					Type.BOOLEAN,
					new Type[] { Type.OBJECT, Type.OBJECT },
					INVOKESTATIC));		
			}
			// if (expr.isOp(BinaryExpr.EQ))
			// 	return Boolean.valueOf(res);
			// else
			// 	return Boolean.valueOf(!res);
			if (expr.isOp(BinaryExpr.NE))
			{
				BranchInstruction branch1 = instrFactory.createBranchInstruction(
					IFNE, null);
				instrList.append(branch1);
				instrList.append(new PUSH(constGen, 1));
				BranchInstruction branch2 = instrFactory.createBranchInstruction(
					GOTO, null);
				instrList.append(branch2);
				branch1.setTarget(instrList.append(
					new PUSH(constGen, 0)));
				branch2.setTarget(instrList.append(InstructionConstants.NOP));
			}
			
			instrList.append(instrFactory.createInvoke(
				Boolean.class.getName(), "valueOf",
				Type.getType(Boolean.class),
				new Type[] { Type.BOOLEAN },
				INVOKESTATIC));				
			return Boolean.class;
			}

		case BinaryExpr.LT: {
			// return Boolean.valueOf(evalExprAsNumber(expr.getLeft()) < evalExprAsNumber(expr.getRight()));
			compileSubExprAsNumberValue(expr.getLeft(), methodGen, instrList);
			compileSubExprAsNumberValue(expr.getRight(), methodGen, instrList);
			instrList.append(InstructionConstants.DCMPG);
			BranchInstruction branch1 = instrFactory.createBranchInstruction(
				IFLT, null);
			instrList.append(branch1);
			instrList.append(new PUSH(constGen, 0));
			BranchInstruction branch2 = 
				instrFactory.createBranchInstruction(GOTO, null); 					
			instrList.append(branch2);
			branch1.setTarget(instrList.append(new PUSH(constGen, 1)));
			branch2.setTarget(instrList.append(InstructionConstants.NOP));
			
			instrList.append(instrFactory.createInvoke(
				Boolean.class.getName(), "valueOf",
				Type.getType(Boolean.class),
				new Type[] { Type.BOOLEAN },
				INVOKESTATIC));
			return Boolean.class;
			}
			
		case BinaryExpr.LE: {
			// return Boolean.valueOf(evalExprAsNumber(expr.getLeft()) <= evalExprAsNumber(expr.getRight()));
			compileSubExprAsNumberValue(expr.getLeft(), methodGen, instrList);
			compileSubExprAsNumberValue(expr.getRight(), methodGen, instrList);
			instrList.append(InstructionConstants.DCMPG);
			BranchInstruction branch1 = instrFactory.createBranchInstruction(
				IFLE, null);
			instrList.append(branch1);
			instrList.append(new PUSH(constGen, 0));
			BranchInstruction branch2 = 
				instrFactory.createBranchInstruction(GOTO, null); 					
			instrList.append(branch2);
			branch1.setTarget(instrList.append(new PUSH(constGen, 1)));
			branch2.setTarget(instrList.append(InstructionConstants.NOP));
			
			instrList.append(instrFactory.createInvoke(
				Boolean.class.getName(), "valueOf",
				Type.getType(Boolean.class),
				new Type[] { Type.BOOLEAN },
				INVOKESTATIC));
			return Boolean.class;
			}
			
		case BinaryExpr.GT: {
			// return Boolean.valueOf(evalExprAsNumber(expr.getLeft()) > evalExprAsNumber(expr.getRight()));
			compileSubExprAsNumberValue(expr.getLeft(), methodGen, instrList);
			compileSubExprAsNumberValue(expr.getRight(), methodGen, instrList);
			instrList.append(InstructionConstants.DCMPL);
			BranchInstruction branch1 = instrFactory.createBranchInstruction(
				IFGT, null);
			instrList.append(branch1);
			instrList.append(new PUSH(constGen, 0));
			BranchInstruction branch2 =
				instrFactory.createBranchInstruction(GOTO, null); 					
			instrList.append(branch2);
			branch1.setTarget(instrList.append(new PUSH(constGen, 1)));
			branch2.setTarget(instrList.append(InstructionConstants.NOP));
			
			instrList.append(instrFactory.createInvoke(
				Boolean.class.getName(), "valueOf",
				Type.getType(Boolean.class),
				new Type[] { Type.BOOLEAN },
				INVOKESTATIC));
			return Boolean.class;
			}

		case BinaryExpr.GE: {
			// return Boolean.valueOf(evalExprAsNumber(expr.getLeft()) >= evalExprAsNumber(expr.getRight()));
			compileSubExprAsNumberValue(expr.getLeft(), methodGen, instrList);
			compileSubExprAsNumberValue(expr.getRight(), methodGen, instrList);
			instrList.append(InstructionConstants.DCMPL);
			BranchInstruction branch1 = instrFactory.createBranchInstruction(
				IFGE, null);
			instrList.append(branch1);
			instrList.append(new PUSH(constGen, 0));
			BranchInstruction branch2 =
				instrFactory.createBranchInstruction(GOTO, null); 					
			instrList.append(branch2);
			branch1.setTarget(instrList.append(new PUSH(constGen, 1)));
			branch2.setTarget(instrList.append(InstructionConstants.NOP));
			
			instrList.append(instrFactory.createInvoke(
				Boolean.class.getName(), "valueOf",
				Type.getType(Boolean.class),
				new Type[] { Type.BOOLEAN },
				INVOKESTATIC));
			return Boolean.class;
			}

		case BinaryExpr.PLUS:
			// return new Double(evalExprAsNumber(expr.getLeft()) + evalExprAsNumber(expr.getRight()));
			compileSubExprAsNumberValue(expr.getLeft(), methodGen, instrList);
			compileSubExprAsNumberValue(expr.getRight(), methodGen, instrList);
			instrList.append(InstructionConstants.DADD);
			
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(), "doubleValueOf",
				Type.getType(Double.class),
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));								
			return Double.class;

		case BinaryExpr.MINUS:
			// return new Double(evalExprAsNumber(expr.getLeft()) - evalExprAsNumber(expr.getRight()));
			compileSubExprAsNumberValue(expr.getLeft(), methodGen, instrList);
			compileSubExprAsNumberValue(expr.getRight(), methodGen, instrList);
			instrList.append(InstructionConstants.DSUB);
			
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(), "doubleValueOf",
				Type.getType(Double.class),
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));								
			return Double.class;
			
		case BinaryExpr.TIMES:
			// return new Double(evalExprAsNumber(expr.getLeft()) * evalExprAsNumber(expr.getRight()));
			compileSubExprAsNumberValue(expr.getLeft(), methodGen, instrList);
			compileSubExprAsNumberValue(expr.getRight(), methodGen, instrList);
			instrList.append(InstructionConstants.DMUL);
			
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(), "doubleValueOf",
				Type.getType(Double.class),
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));								
			return Double.class;
			
		case BinaryExpr.DIV:
			// return new Double(evalExprAsNumber(expr.getLeft()) / evalExprAsNumber(expr.getRight()));
			compileSubExprAsNumberValue(expr.getLeft(), methodGen, instrList);
			compileSubExprAsNumberValue(expr.getRight(), methodGen, instrList);
			instrList.append(InstructionConstants.DDIV);
			
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(), "doubleValueOf",
				Type.getType(Double.class),
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));								
			return Double.class;

		case BinaryExpr.MOD:
			// return new Double(evalExprAsNumber(expr.getLeft()) % evalExprAsNumber(expr.getRight()));
			compileSubExprAsNumberValue(expr.getLeft(), methodGen, instrList);
			compileSubExprAsNumberValue(expr.getRight(), methodGen, instrList);
			instrList.append(InstructionConstants.DREM);
			
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(), "doubleValueOf",
				Type.getType(Double.class),
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));								
			return Double.class;

		default: throw new LSPException("Unrecognized binary operator: "
			+ expr.getOp());
		}
	}


	private Class<?> compileSubExpr(UnaryExpr expr,
			MethodGen methodGen, InstructionList instrList)	
		throws SAXException
	{
		LSPExpr left = expr.getLeft();
		
		if (left instanceof NumberLiteral)
		{
			instrList.append(new PUSH(constGen, -((NumberLiteral)left).getValue()));
		}
		else
		{
			// return new Double(-evalExprAsNumber(left));
			compileSubExprAsNumberValue(left, methodGen, instrList);
			instrList.append(InstructionConstants.DNEG);
		}								

		instrList.append(instrFactory.createInvoke(
			LSPPageBase.class.getName(), "doubleValueOf",
			Type.getType(Double.class),
			new Type[] { Type.DOUBLE },
			INVOKESTATIC));								
		return Double.class;
	}


	private Class<?> compileSubExpr(BuiltInFunctionCall expr,
			MethodGen methodGen, InstructionList instrList)	
		throws SAXException
	{
		if (expr.getName().equals("string"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"string() function must have 1 argument");

			// return evalExprAsString(expr.getArg(0));
			compileSubExprAsString(expr.getArg(0), methodGen, instrList);

			return String.class;
		}
		else if (expr.getName().equals("concat"))
		{
			if (expr.numberOfArgs() < 2)
				throw new LSPException(
					"concat() function must have at least 2 argument");

			// StringBuffer sb = new StringBuffer(expr.getArg(0));
			instrList.append(instrFactory.createNew(StringBuffer.class.getName()));
			instrList.append(InstructionConstants.DUP);
			compileSubExprAsString(expr.getArg(0), methodGen, instrList);
			instrList.append(instrFactory.createInvoke(
				StringBuffer.class.getName(), "<init>", Type.VOID, 
				new Type[] { Type.STRING }, INVOKESPECIAL));
			
			for (int i = 1; i<expr.numberOfArgs(); i++)
			{
				// sb.append(evalExprAsString(expr.getArg(i)));
				compileSubExprAsString(expr.getArg(i), methodGen, instrList);
				instrList.append(instrFactory.createInvoke(
					StringBuffer.class.getName(), "append", 
					Type.STRINGBUFFER, 
					new Type[] { Type.STRING }, INVOKEVIRTUAL));
			}
			// return sb.toString();
			instrList.append(instrFactory.createInvoke(
				StringBuffer.class.getName(), "toString", Type.STRING, 
				Type.NO_ARGS, INVOKEVIRTUAL));
				
			return String.class;				
		}
		else if (expr.getName().equals("starts-with"))
		{
			if (expr.numberOfArgs() != 2)
				throw new LSPException(
					"starts-with() function must have 2 arguments");

			// String a = evalExprAsString(expr.getArg(0));
			compileSubExprAsString(expr.getArg(0), methodGen, instrList);
			// String b = evalExprAsString(expr.getArg(1));
			compileSubExprAsString(expr.getArg(1), methodGen, instrList);
			// return Boolean.valueOf(a.startsWith(b));
			instrList.append(instrFactory.createInvoke(
				String.class.getName(), "startsWith", Type.BOOLEAN, 
				new Type[] { Type.STRING }, INVOKEVIRTUAL));
			
			instrList.append(instrFactory.createInvoke(
				Boolean.class.getName(), "valueOf",
				Type.getType(Boolean.class),
				new Type[] { Type.BOOLEAN },
				INVOKESTATIC));		
			return Boolean.class;
		}
		else if (expr.getName().equals("contains"))
		{
			if (expr.numberOfArgs() != 2)
				throw new LSPException(
					"contains() function must have 2 arguments");

			// String a = evalExprAsString(expr.getArg(0));
			compileSubExprAsString(expr.getArg(0), methodGen, instrList);
			// String b = evalExprAsString(expr.getArg(1));
			compileSubExprAsString(expr.getArg(1), methodGen, instrList);					

			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"fnContains",
				Type.BOOLEAN,
				new Type[] { Type.STRING, Type.STRING },
				INVOKESTATIC));					

			instrList.append(instrFactory.createInvoke(
				Boolean.class.getName(), "valueOf",
				Type.getType(Boolean.class),
				new Type[] { Type.BOOLEAN },
				INVOKESTATIC));		
			return Boolean.class;
		}
		else if (expr.getName().equals("substring-before"))
		{
			if (expr.numberOfArgs() != 2)
				throw new LSPException(
					"substring-before() function must have 2 arguments");

			// String a = evalExprAsString(expr.getArg(0));
			compileSubExprAsString(expr.getArg(0), methodGen, instrList);
			// String b = evalExprAsString(expr.getArg(1));
			compileSubExprAsString(expr.getArg(1), methodGen, instrList);

			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"fnSubstringBefore",
				Type.STRING,
				new Type[] { Type.STRING, Type.STRING },
				INVOKESTATIC));					

			return String.class;
		}
		else if (expr.getName().equals("substring-after"))
		{
			if (expr.numberOfArgs() != 2)
				throw new LSPException(
					"substring-after() function must have 2 arguments");

			// String a = evalExprAsString(expr.getArg(0));
			compileSubExprAsString(expr.getArg(0), methodGen, instrList);
			// String b = evalExprAsString(expr.getArg(1));
			compileSubExprAsString(expr.getArg(1), methodGen, instrList);

			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"fnSubstringAfter",
				Type.STRING,
				new Type[] { Type.STRING, Type.STRING },
				INVOKESTATIC));					

			return String.class;
		}
		else if (expr.getName().equals("substring"))
		{
			if ((expr.numberOfArgs() != 2) && (expr.numberOfArgs() != 3))
				throw new LSPException(
					"substring() function must have 2 or 3 arguments");
					
			// String a = evalExprAsString(expr.getArg(0));
			compileSubExprAsString(expr.getArg(0), methodGen, instrList);
			// double bd = evalExprAsNumber(expr.getArg(1));
			compileSubExprAsNumberValue(expr.getArg(1), methodGen, instrList);
			
			if (expr.numberOfArgs() == 3)
			{
				// double cd = evalExprAsNumber(expr.getArg(2));
				compileSubExprAsNumberValue(expr.getArg(2), methodGen, instrList);

				instrList.append(instrFactory.createInvoke(
					LSPPageBase.class.getName(),
					"fnSubstring",
					Type.STRING,
					new Type[] { Type.STRING, Type.DOUBLE, Type.DOUBLE },
					INVOKESTATIC));					
			}
			else
			{
				instrList.append(instrFactory.createInvoke(
					LSPPageBase.class.getName(),
					"fnSubstring",
					Type.STRING,
					new Type[] { Type.STRING, Type.DOUBLE },
					INVOKESTATIC));					
			}

			return String.class;
		}
		else if (expr.getName().equals("string-length"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"string-length() function must have 1 argument");

			// String a = evalExprAsString(expr.getArg(0));
			compileSubExprAsString(expr.getArg(0), methodGen, instrList);

			// return new Double(a.length());
			instrList.append(instrFactory.createInvoke(
				String.class.getName(), "length", Type.INT, 
				Type.NO_ARGS, INVOKEVIRTUAL));
			instrList.append(InstructionConstants.I2D);
			
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(), "doubleValueOf",
				Type.getType(Double.class),
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));								
			return Double.class;								
		}
		else if (expr.getName().equals("normalize-space"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"normalize-space() function must have 1 argument");

			// String a = evalExprAsString(expr.getArg(0));
			compileSubExprAsString(expr.getArg(0), methodGen, instrList);

			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"fnNormalizeSpace",
				Type.STRING,
				new Type[] { Type.STRING },
				INVOKESTATIC));								

			return String.class;								
		}
		else if (expr.getName().equals("translate"))
		{
			if (expr.numberOfArgs() != 3)
				throw new LSPException(
					"translate() function must have 3 arguments");

			// String a = evalExprAsString(expr.getArg(0));
			compileSubExprAsString(expr.getArg(0), methodGen, instrList);
			// String b = evalExprAsString(expr.getArg(1));
			compileSubExprAsString(expr.getArg(1), methodGen, instrList);
			// String c = evalExprAsString(expr.getArg(2));
			compileSubExprAsString(expr.getArg(2), methodGen, instrList);

			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"fnTranslate",
				Type.STRING,
				new Type[] { Type.STRING, Type.STRING, Type.STRING },
				INVOKESTATIC));								

			return String.class;								
		}
		else if (expr.getName().equals("boolean"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"boolean() function must have 1 argument");

			// return Boolean.valueOf(evalExprAsBoolean(expr.getArg(0)));
			Class<?> type = compileSubExpr(expr.getArg(0), methodGen, instrList);
			if (type != Boolean.class)
			{
				instrList.append(instrFactory.createInvoke(
					LSPPageBase.class.getName(),
					acceptUnbound ? "convertToBooleanAcceptNull" : "convertToBoolean",
					Type.BOOLEAN,
					new Type[] { Type.OBJECT },
					INVOKESTATIC));
				instrList.append(instrFactory.createInvoke(
					Boolean.class.getName(), "valueOf",
					Type.getType(Boolean.class),
					new Type[] { Type.BOOLEAN },
					INVOKESTATIC));
			}
			return Boolean.class;								
		}
		else if (expr.getName().equals("not"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"not() function must have 1 argument");

			// return Boolean.valueOf(!evalExprAsBoolean(expr.getArg(0)));
			compileSubExprAsBooleanValue(expr.getArg(0), methodGen, instrList);
			BranchInstruction branch1 = instrFactory.createBranchInstruction(
				IFNE, null);
			instrList.append(branch1);
			instrList.append(new PUSH(constGen, 1));
			BranchInstruction branch2 = instrFactory.createBranchInstruction(
				GOTO, null);
			instrList.append(branch2);
			branch1.setTarget(instrList.append(
				new PUSH(constGen, 0)));
			branch2.setTarget(instrList.append(InstructionConstants.NOP));
			
			instrList.append(instrFactory.createInvoke(
					Boolean.class.getName(), "valueOf",
					Type.getType(Boolean.class),
					new Type[] { Type.BOOLEAN },
					INVOKESTATIC));								
			return Boolean.class;								
		}
		else if (expr.getName().equals("true"))
		{
			if (expr.numberOfArgs() != 0)
				throw new LSPException(
					"true() function must have no arguments");

			// return Boolean.TRUE;
			instrList.append(new PUSH(constGen, 1));

			instrList.append(instrFactory.createInvoke(
					Boolean.class.getName(), "valueOf",
					Type.getType(Boolean.class),
					new Type[] { Type.BOOLEAN },
					INVOKESTATIC));								
			return Boolean.class;								
		}
		else if (expr.getName().equals("false"))
		{
			if (expr.numberOfArgs() != 0)
				throw new LSPException(
					"false() function must have no arguments");

			// return Boolean.FALSE;
			instrList.append(new PUSH(constGen, 0));

			instrList.append(instrFactory.createInvoke(
					Boolean.class.getName(), "valueOf",
					Type.getType(Boolean.class),
					new Type[] { Type.BOOLEAN },
					INVOKESTATIC));
			return Boolean.class;								
		}
		else if (expr.getName().equals("number"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"number() function must have 1 argument");

			// return new Double(evalExprAsNumber(expr.getArg(0)));
			Class<?> type = compileSubExpr(expr.getArg(0), methodGen, instrList);
			if (type != Double.class)
			{
				instrList.append(instrFactory.createInvoke(
					LSPPageBase.class.getName(),
					"convertToNumber",
					Type.DOUBLE,
					new Type[] { Type.OBJECT },
					INVOKESTATIC));
				instrList.append(instrFactory.createInvoke(
					LSPPageBase.class.getName(),
					"doubleValueOf",
					Type.getType(Double.class),
					new Type[] { Type.DOUBLE },
					INVOKESTATIC));
			}
			return Double.class;								
		}
		else if (expr.getName().equals("floor"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"floor() function must have 1 argument");

			// return new Double(Math.floor(evalExprAsNumber(expr.getArg(0))));
			compileSubExprAsNumberValue(expr.getArg(0), methodGen, instrList);
			instrList.append(instrFactory.createInvoke(
				Math.class.getName(),
				"floor",
				Type.DOUBLE,
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));

			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(), "doubleValueOf",
				Type.getType(Double.class),
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));																			
			return Double.class;								
		}
		else if (expr.getName().equals("ceiling"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"ceiling() function must have 1 argument");

			// return new Double(Math.ceil(evalExprAsNumber(expr.getArg(0))));
			compileSubExprAsNumberValue(expr.getArg(0), methodGen, instrList);
			instrList.append(instrFactory.createInvoke(
				Math.class.getName(),
				"ceil",
				Type.DOUBLE,
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));

			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(), "doubleValueOf",
				Type.getType(Double.class),
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));																			
			return Double.class;								
		}
		else if (expr.getName().equals("round"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"round() function must have 1 argument");

			// double a = evalExprAsNumber(expr.getArg(0));
			compileSubExprAsNumberValue(expr.getArg(0), methodGen, instrList);			

			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"fnRound",
				Type.DOUBLE,
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));

			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(), "doubleValueOf",
				Type.getType(Double.class),
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));																			
			return Double.class;																			
		}
		else if (expr.getName().equals("count"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"count() function must have 1 argument");

			// Collection list = evalExprAsList(expr.getArg(0));
			compileSubExprAsList(expr.getArg(0), methodGen, instrList);

			// return new Double(list.length());
			instrList.append(instrFactory.createInvoke(
				Collection.class.getName(),
				"size",
				Type.INT,
				Type.NO_ARGS,
				INVOKEINTERFACE));
				
			instrList.append(InstructionConstants.I2D);
			
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(), "doubleValueOf",
				Type.getType(Double.class),
				new Type[] { Type.DOUBLE },
				INVOKESTATIC));	
			return Double.class;								
		}
		else if (expr.getName().equals("seq"))
		{
			if (expr.numberOfArgs() < 2)
				throw new LSPException(
					"seq() function must have at least 2 arguments");
					
			// double start = evalExprAsNumber(expr.getArg(0));
			compileSubExprAsNumberValue(expr.getArg(0), methodGen, instrList);
			// double end = evalExprAsNumber(expr.getArg(1));
			compileSubExprAsNumberValue(expr.getArg(1), methodGen, instrList);
			// double step = (expr.numberOfArgs() > 2) 
				// ? evalExprAsNumber(expr.getArg(2))
				// : 1.0;
			if (expr.numberOfArgs() > 2)
				compileSubExprAsNumberValue(expr.getArg(2), methodGen, instrList);
			else
				instrList.append(new PUSH(constGen, 1.0d));

			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"fnSeq",
				Type.getType(Collection.class),
				new Type[] { Type.DOUBLE, Type.DOUBLE, Type.DOUBLE },
				INVOKESTATIC));											

			return Collection.class;
		}
		else if (expr.getName().equals("isset"))
		{
			if (expr.numberOfArgs() != 1)
				throw new LSPException(
					"isset() function must have 1 argument");

            LSPExpr theVar = expr.getArg(0);
            if (theVar instanceof VariableReference)
            {
                String varName = ((VariableReference)theVar).getName(); 
                
                instrList.append(instrFactory.createLoad(
                    Type.getType(Environment.class), PARAM_env));
                instrList.append(new PUSH(constGen, varName));
                
                instrList.append(instrFactory.createInvoke(
                    Environment.class.getName(),
                    "containsKey",
                    Type.BOOLEAN,
                    new Type[] { Type.OBJECT },
                    INVOKEVIRTUAL));
                    
                instrList.append(instrFactory.createInvoke(
                    Boolean.class.getName(), "valueOf",
                    Type.getType(Boolean.class),
                    new Type[] { Type.BOOLEAN },
                    INVOKESTATIC));			                
                return Boolean.class;
            }
            else                        
            {
				throw new LSPException(
                    "argument to isset() function must be a variable"); 
            }                                                                                
		}
        else if (expr.getName().equals("haselement"))
        {
            if (expr.numberOfArgs() != 2)
                throw new LSPException(
                    "haselement() function must have 2 arguments");

            // Map tuple = evalExprAsTuple(expr.getBase());
            compileSubExprAsTuple(expr.getArg(0), methodGen, instrList);
            // String key = evalSubExprAsString(expr.getKey());
            compileSubExprAsString(expr.getArg(1), methodGen, instrList);        

            instrList.append(instrFactory.createInvoke(
                Map.class.getName(),
                "containsKey",
                Type.BOOLEAN,
                new Type[] { Type.OBJECT },
                INVOKEINTERFACE));     
            
            instrList.append(instrFactory.createInvoke(
                Boolean.class.getName(), "valueOf",
                Type.getType(Boolean.class),
                new Type[] { Type.BOOLEAN },
                INVOKESTATIC));                         
            return Boolean.class;
        }
        else if (expr.getName().equals("isnull"))
        {
            if (expr.numberOfArgs() != 1)
                throw new LSPException(
                    "isnull() function must have 1 argument");

            compileSubExpr(expr.getArg(0), methodGen, instrList);
            BranchInstruction branch1 = instrFactory.createBranchInstruction(
                    IFNULL, null);            
            instrList.append(branch1);

            instrList.append(new PUSH(constGen, 0)); // FALSE
            
            BranchInstruction branch2 = instrFactory.createBranchInstruction(
                    GOTO, null);
            instrList.append(branch2);
            
            branch1.setTarget(instrList.append(new PUSH(constGen, 1))); // TRUE            

            branch2.setTarget(instrList.append(InstructionConstants.NOP));            
            
            instrList.append(instrFactory.createInvoke(
                    Boolean.class.getName(), "valueOf",
                    Type.getType(Boolean.class),
                    new Type[] { Type.BOOLEAN },
                    INVOKESTATIC));                         
            return Boolean.class;
        }
        else if (expr.getName().equals("nvl"))
        {
            if (expr.numberOfArgs() != 2)
                throw new LSPException(
                    "nvl() function must have 2 arguments");

            compileSubExpr(expr.getArg(0), methodGen, instrList);
            instrList.append(InstructionConstants.DUP);            
            BranchInstruction branch1 = instrFactory.createBranchInstruction(
                    IFNONNULL, null);            
            instrList.append(branch1);
            
            instrList.append(InstructionConstants.POP);
            compileSubExpr(expr.getArg(1), methodGen, instrList);        

            branch1.setTarget(instrList.append(InstructionConstants.NOP));
            return Object.class;
        }
		else
		{
			throw new LSPException("Unrecognized built-in function: "
				+ expr.getName());
		}
	}


	private Class<?> compileSubExpr(ExtensionFunctionCall expr,
			MethodGen methodGen, InstructionList instrList)	
		throws SAXException
	{
		// LSPExtLib extLib = (LSPExtLib)extLibs.get();
		instrList.append(instrFactory.createLoad(
			Type.getType(Map.class), PARAM_extLibs));
		instrList.append(new PUSH(constGen, expr.getClassName()));
		instrList.append(instrFactory.createInvoke(
			Map.class.getName(),
			"get",
			Type.OBJECT,
			new Type[] { Type.OBJECT },
			INVOKEINTERFACE));
			
		instrList.append(instrFactory.createCast(
			Type.OBJECT, Type.getType("L"+expr.getClassName().replace('.','/')+";")));
					
		Type[] argTypes = new Type[expr.numberOfArgs()];
		for (int i = 0; i<expr.numberOfArgs(); i++)
		{
			argTypes[i] = Type.OBJECT;
			compileSubExpr(expr.getArg(i), methodGen, instrList);
		}		

		// Object res = extLib._funcName(args);		
		instrList.append(instrFactory.createInvoke(
			expr.getClassName(),
			"_"+expr.getName(),
			Type.OBJECT,
			argTypes,
			INVOKEVIRTUAL));

		return Object.class;
	}
	
	
	private Class<?> compileSubExpr(TupleExpr expr,
			MethodGen methodGen, InstructionList instrList)	
		throws SAXException
	{
		// Map tuple = evalExprAsTuple(expr.getBase());
		compileSubExprAsTuple(expr.getBase(), methodGen, instrList);
		// String key = evalSubExprAsString(expr.getKey());
		compileSubExprAsString(expr.getKey(), methodGen, instrList); 		

		instrList.append(instrFactory.createInvoke(
			LSPPageBase.class.getName(),
			acceptUnbound ? "getElementFromTupleAcceptNull" : "getElementFromTuple",
			Type.OBJECT,
			new Type[] { Type.getType(Map.class), Type.STRING },
			INVOKESTATIC));		

		return Object.class;
	}
	
	
	private Class<?> compileSubExpr(ConditionalExpr expr,
			MethodGen methodGen, InstructionList instrList)	
		throws SAXException
	{
		// if (evalExprAsBoolean(expr.getTest()))
		// 	return evalSubExpr(expr.getThen());	
		// else
		//	return evalSubExpr(expr.getElse());
		compileSubExprAsBooleanValue(expr.getTest(), methodGen, instrList);
		BranchInstruction branch1 = instrFactory.createBranchInstruction(
			IFEQ, null);
		instrList.append(branch1);

		compileSubExpr(expr.getThen(), methodGen, instrList);
		BranchInstruction branch2 = instrFactory.createBranchInstruction(
			GOTO, null);
		instrList.append(branch2);
		
		branch1.setTarget(instrList.append(InstructionConstants.NOP));
		
		compileSubExpr(expr.getElse(), methodGen, instrList);

		branch2.setTarget(instrList.append(InstructionConstants.NOP));
		
		return Object.class;
	}

	
	private void compileSubExprAsString(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)	
		throws SAXException
	{
		Class<?> type = compileSubExpr(expr, methodGen, instrList);
		if (type != String.class)
		{
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"convertToString",
				Type.STRING,
				new Type[] { Type.OBJECT },
				INVOKESTATIC));
		}
	}


	// returns double value
	private void compileSubExprAsNumberValue(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)	
		throws SAXException
	{
		Class<?> type = compileSubExpr(expr, methodGen, instrList);
		if (type != Double.class)
		{			
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"convertToNumber",
				Type.DOUBLE,
				new Type[] { Type.OBJECT },				
				INVOKESTATIC));		
		}				
		else
		{
			try {
				instrList.delete(instrList.getEnd());
			}
			catch (TargetLostException e)
			{
				throw new LSPException("Internal error in LSP compiler: " + e.getMessage());	
			}
		}	
	}

		
	// returns boolean value
	private void compileSubExprAsBooleanValue(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)	
		throws SAXException
	{
		Class<?> type = compileSubExpr(expr, methodGen, instrList);
		if (type != Boolean.class)
		{
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				acceptUnbound ? "convertToBooleanAcceptNull" : "convertToBoolean",
				Type.BOOLEAN,
				new Type[] { Type.OBJECT },
				INVOKESTATIC));
		}
		else
		{
			try {
				instrList.delete(instrList.getEnd());
			}
			catch (TargetLostException e)
			{
				throw new LSPException("Internal error in LSP compiler: " + e.getMessage());	
			}
		}
	}


	private void compileSubExprAsList(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)	
		throws SAXException
	{
		Class<?> type = compileSubExpr(expr, methodGen, instrList);
		if (type != Collection.class)
		{
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"convertToList",
				Type.getType(Collection.class),
				new Type[] { Type.OBJECT },
				INVOKESTATIC));
		}
	}

	
	private void compileSubExprAsTuple(LSPExpr expr,
			MethodGen methodGen, InstructionList instrList)	
		throws SAXException
	{
		Class<?> type = compileSubExpr(expr, methodGen, instrList);
		if (type != Map.class)
		{
			instrList.append(instrFactory.createInvoke(
				LSPPageBase.class.getName(),
				"convertToTuple",
				Type.getType(Map.class),
				new Type[] { Type.OBJECT },
				INVOKESTATIC));
		}
	}
	
}

